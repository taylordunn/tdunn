---
title: "Advent of Code 2021"
description: |
  My solutions to the #AdventOfCode2021 coding challenges.
author:
  - name: Taylor Dunn
date: 2021-12-01
params:
  date: 2021-12-01
  slug: "advent-of-code-2021"
categories:
  - Advent of Code
  - Python
draft: false
output:
  distill::distill_article:
    self_contained: false
    toc: true
#bibliography: references.bib
---

```{r setup, include=TRUE, code_folding="Setup"}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(dunnr)
library(here)

extrafont::loadfonts(device = "win", quiet = TRUE)
theme_set(theme_td())
set_geom_fonts()
set_palette()
```


The [Advent of Code](https://adventofcode.com/) has begun for 2021, and I decided to participate this year to work on my programming and problem solving skills in R and, where possible, I'll try to translate the solutions to Python.
Load the `reticulate` package:

```{r python-setup}
Sys.setenv(
  RETICULATE_PYTHON = here("..", "python", ".venv", "Scripts", "python.exe")
)
library(reticulate)
py_config()
```


I'll also be "competing" in a private leaderboard started by [Tan Ho](https://twitter.com/_TanHo/status/1465310512716173313).
I don't expect to rank highly here because the puzzles are released at 1AM my time (and scores are based on time from release) but it'll be a good source of motivation throughout the month.
There are 25 days of challenges, so my current plan is to split up the posts into 5-day chunks.

## Day 1

### Part 1

>The first order of business is to figure out how quickly the depth increases, just so you know what you're dealing with - you never know if the keys will get carried into deeper water by an ocean current or a fish or something.
To do this, count the number of times a depth measurement increases from the previous measurement. (There is no measurement before the first measurement.)

Import the measurements:

```{r}
day1 <- read_lines(here("_posts", "2021-12-01-advent-of-code-2021",
                     "day01-input.txt")) %>%
  as.integer()
head(day1)
```

The `tidyverse` solution to this problem is to use the `dplyr::lag()`/`lead()` function to refer to previous/next values.
For example, for a vector of values 1-10 (in random order), I can show the cases where the value has increased like this:

```{r}
d <- sample(1:10)
bind_cols(
  value = d,
  increased = d > dplyr::lag(d)
)
```

Excluding the `NA` value, which occurs due to being the first element, `sum()` up the cases of larger measurements:

```{r}
sum(lag(day1) < day1, na.rm = TRUE)
```

For the Python solution, I will use the `numpy.diff` function to calculate the difference between consecutive values:

```{python}
import numpy as np

# Reference an object from the R session with r.obj
(np.diff(r.day1) > 0)
```

Then chain the `.sum()` function to add up the `True` values:

```{python}
(np.diff(r.day1) > 0).sum()
```

Note that this method is also possible in base R, and is a bit simpler than the `tidyverse` solution:

```{r}
sum(diff(day1) > 0)
```

### Part 2

>Your goal now is to count the number of times the sum of measurements in this sliding window increases from the previous sum. So, compare A with B, then compare B with C, then C with D, and so on. Stop when there aren't enough measurements left to create a new three-measurement sum.

Here, I will use both `lag` and `lead` to compute the sum of the window:

```{r}
d_sum3 <- lag(d) + d + lead(d)
bind_cols(
  value = d,
  sum3 = d_sum3,
  increased = lag(d_sum3) < d_sum3
)
```

Now `sum` the number of increases in the day 1 data:

```{r}
day1_sum3 <- lag(day1) + day1 + lead(day1)
sum(day1_sum3 > lag(day1_sum3), na.rm = TRUE)
```

In Python, the `np.convolve` function allows computation in sliding windows:

```{python}
np.convolve(r.day1, np.ones(3, dtype = int))
```

Above, we provided the `np.ones(3, dtype = int)` array which is simply `[1, 1, 1]` and works as the convolution operator that slides along the `r.day1` array.
Note that the first two elements are not correct, however, because the boundaries (with fewer than 3 values) were returned.
Fix this with the `mode` argument:

```{python}
np.convolve(r.day1, np.ones(3, dtype = int), mode = 'valid')
(np.diff(np.convolve(r.day1, np.ones(3, dtype = int), mode = 'valid')) > 0) \
  .sum()
```

## Day 2

### Part 1

>Your horizontal position and depth both start at 0. The steps above would then modify them as follows:

>* forward 5 adds 5 to your horizontal position, a total of 5.
* down 5 adds 5 to your depth, resulting in a value of 5.
* forward 8 adds 8 to your horizontal position, a total of 13.
* up 3 decreases your depth by 3, resulting in a value of 2.
* down 8 adds 8 to your depth, resulting in a value of 10.
* forward 2 adds 2 to your horizontal position, a total of 15.

>Calculate the horizontal position and depth you would have after following the planned course. What do you get if you multiply your final horizontal position by your final depth?

Import the steps:

```{r}
day2 <- read_lines(here("_posts", "2021-12-01-advent-of-code-2021",
                     "day02-input.txt"))
head(day2)
```

Put it in a `tibble`, and `tidyr::separate` the instruction and the amount:

```{r}
d_day2 <- tibble(step = day2) %>%
  separate(step, into = c("instruction", "amount"), sep = " ", convert = TRUE)
head(d_day2)
```

Then summarize the horizontal position and depth, and multiply the result:

```{r}
d_day2 %>%
  summarise(
    horizontal_position = sum(amount[instruction == "forward"]),
    # Depth is inverse, so down - up
    depth = sum(amount[instruction == "down"]) -
      sum(amount[instruction == "up"]),
    .groups = "drop"
  ) %>%
  mutate(product = horizontal_position * depth)
```

For the Python solution, I'll use `pandas`:

```{python}
import pandas as pd

day2_df = pd.DataFrame(r.day2, dtype = str, columns = ['step']) \
  .step.str.split(' ', expand = True) \
  .rename(columns = {0: 'instruction', 1: 'amount'}) \
  .astype({'amount': 'int32'})
day2_df
```

Then it is easy enough to sum up the different columns:

```{python}
day2_df[day2_df.instruction == 'forward'].amount.sum()
day2_df[day2_df.instruction == 'down'].amount.sum() - \
  day2_df[day2_df.instruction == 'up'].amount.sum()
```

Here is another way with the `groupby` and `aggregate` functions:

```{python, eval=FALSE}
day2_df_sum = day2_df \
  .groupby('instruction', as_index = True) \
  .aggregate('sum')
  
day2_df_sum.loc['forward'].amount
day2_df_sum.loc['down'].amount - day2_df_sum.loc['up'].amount
```

### Part 2

>In addition to horizontal position and depth, you'll also need to track a third value, aim, which also starts at 0. The commands also mean something entirely different than you first thought:

>* down X increases your aim by X units.
* up X decreases your aim by X units.
* forward X does two things:
  * It increases your horizontal position by X units.
  * It increases your depth by your aim multiplied by X.
  
>Using this new interpretation of the commands, calculate the horizontal position and depth you would have after following the planned course. What do you get if you multiply your final horizontal position by your final depth?

First, I'll use `cumsum()` to add a running total of the `aim` variable from the "down" and "up" instructions:

```{r}
d_day2 <- d_day2 %>%
  mutate(
    # Have to use a placeholder variable so it has the same length as the
    #  "aim" variable below
    aim_placeholder = case_when(
      instruction == "down" ~ amount,
      instruction == "up" ~ -amount,
      TRUE ~ 0L
    ),
    aim = cumsum(aim_placeholder)
  ) %>%
  select(-aim_placeholder)
head(d_day2, 9)
```

Now with the running total of `aim`, I can compute horizontal position and depth:

```{r}
d_day2 %>%
  summarise(
    horizontal_position = sum(amount[instruction == "forward"]),
    depth = sum(
      # Depth is forward multiplied by aim
      aim[instruction == "forward"] * amount[instruction == "forward"]
    ),
    .groups = "drop"
  ) %>%
  mutate(product = horizontal_position * depth)
```

In Python, I will `assign` a new aim column, and use the `np.select()` function to conditionally sum the values:

```{python}
day2_df = day2_df \
  .assign(
    aim = np.select(
      [day2_df.instruction == 'down',
       day2_df.instruction == 'up',
       day2_df.instruction == 'forward'],
      [day2_df.amount, -day2_df.amount, 0]
    )
  )
day2_df.aim = day2_df.aim.cumsum()
```

The `aggregate` function can only operate on single columns, so need to make a new `depth` column first by multiplying `aim` with `amount` (for `instruction` = 'forward'):

```{python}
day2_df = day2_df \
  .assign(
    depth = np.where(
      day2_df.instruction == 'forward', day2_df.aim * day2_df.amount, 0
    ),
    horizontal_position = np.where(
      day2_df.instruction == 'forward', day2_df.amount, 0
    )
  )
day2_df 
```

I've also added the `horizontal_position` variable, so that I can compute the sums with a simple `aggregate`:

```{python}
day2_df[['depth', 'horizontal_position']].aggregate('sum')
```

## Reproducibility {.appendix}

<details><summary>Session info</summary>

```{r echo=FALSE}
devtools::session_info()$platform
devtools::session_info()$packages %>%
  rmarkdown::paged_table()
```

</details>

<details><summary>Git repository</summary>

```{r echo=FALSE}
git2r::repository()
```

</details>

```{r echo=FALSE}
get_distill_source(date = params$date, slug = params$slug)
```

