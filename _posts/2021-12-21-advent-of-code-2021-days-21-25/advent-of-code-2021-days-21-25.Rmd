---
title: "Advent of Code: Days 21-25"
description: |
  My solutions to the #AdventOfCode2021 coding challenges, days 21 through 25.
author:
  - name: Taylor Dunn
date: 2021-12-21
params:
  date: 2021-12-21
  slug: "advent-of-code-2021-days-21-25"
categories:
  - Advent of Code
  - Python
  - R
output:
  distill::distill_article:
    self_contained: false
    toc: true
---

```{r setup, include=TRUE, code_folding="R setup"}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(here)
library(gt)
library(tictoc)
library(lubridate)

library(dunnr)
extrafont::loadfonts(device = "win", quiet = TRUE)
theme_set(theme_td_grid())
set_geom_fonts()
set_palette()
```

<details><summary>Python setup</summary>

```{r py-setup1}
Sys.setenv(
  RETICULATE_PYTHON = here("..", "python", ".venv", "Scripts", "python.exe")
)
library(reticulate)
```

```{python py-setup2}
import numpy as np
import pandas as pd
import timeit
```

</details>

## Day 21: Dirac Dice

```{r}
day21 <- read_lines(here("_posts", "2021-12-21-advent-of-code-2021-days-21-25",
                         "day21-input.txt"))
day21 %>% str_trunc(80)
```

### Part 1

>
There's not much to do as you slowly descend to the bottom of the ocean. The submarine computer challenges you to a nice game of Dirac Dice.
>
This game consists of a single die, two pawns, and a game board with a circular track containing ten spaces marked `1` through `10` clockwise. Each player's starting space is chosen randomly (your puzzle input). Player 1 goes first.
>
Players take turns moving. On each player's turn, the player rolls the die three times and adds up the results. Then, the player moves their pawn that many times forward around the track (that is, moving clockwise on spaces in order of increasing value, wrapping back around to `1` after `10`). So, if a player is on space `7` and they roll `2`, `2`, and `1`, they would move forward 5 times, to spaces `8`, `9`, `10`, `1`, and finally stopping on `2`.
>
After each player moves, they increase their score by the value of the space their pawn stopped on. Players' scores start at `0`. So, if the first player starts on space `7` and rolls a total of `5`, they would stop on space `2` and add `2` to their score (for a total score of `2`). The game immediately ends as a win for any player whose score reaches at least `1000`.
>
Since the first game is a practice game, the submarine opens a compartment labeled deterministic dice and a 100-sided die falls out. This die always rolls `1` first, then `2`, then `3`, and so on up to `100`, after which it starts over at 1 again. Play using this die.
>
The moment either player wins, what do you get if you multiply the score of the losing player by the number of times the die was rolled during the game?

```{r}
player1 <- str_extract(day21[1], "position: \\d") %>% readr::parse_number()
player2 <- str_extract(day21[2], "position: \\d") %>% readr::parse_number()
player1; player2
```

Define a custom modulo function that returns 1-10 instead of 0-9:

```{r}
custom_mod <- function(val) {
  ((val - 1) %% 10) + 1
}
```

Loop until a winner is found:

```{r}
player1_score <- player2_score <- dice <- turn <- 0

while (player1_score < 1000 & player2_score < 1000) {
  turn <- turn + 1
  dice <- dice + 3
  
  roll <- sum(seq(dice, dice - 2))
  if (turn %% 2 == 1) {
    player1 <- custom_mod(player1 + roll)
    player1_score <- player1_score + player1
  } else {
    player2 <- custom_mod(player2 + roll)
    player2_score <- player2_score + player2
  }
}
player1_score; player2_score
```

Multiply the turn number by 3 to get the number of dice rolls, then multiply that by the losing players score:

```{r}
(turn * 3) * player2_score
```

Python:

```{python}
player1 = int(r.day21[0][-1])
player2 = int(r.day21[1][-1])

player1_score, player2_score, dice, turn = 0, 0, 0, 0

while player1_score < 1000 and player2_score < 1000:
  turn += 1
  dice += 3
  
  roll = sum(range(dice - 2, dice + 1))
  if turn % 2 == 1:
    player1 = ((player1 + roll - 1) % 10) + 1
    player1_score += player1
  else:
    player2 = ((player2 + roll - 1) % 10) + 1
    player2_score += player2

turn * 3 * player2_score
```

### Part 2

>
Now that you're warmed up, it's time to play the real game.
>
A second compartment opens, this time labeled Dirac dice. Out of it falls a single three-sided die.
>
As you experiment with the die, you feel a little strange. An informational brochure in the compartment explains that this is a quantum die: when you roll it, the universe splits into multiple copies, one copy for each possible outcome of the die. In this case, rolling the die always splits the universe into three copies: one where the outcome of the roll was `1`, one where it was `2`, and one where it was `3`.
>
The game is played the same as before, although to prevent things from getting too far out of hand, the game now ends when either player's score reaches at least `21`.

On each turn, the Dirac dice is rolled three times, leading to $3 \times 3 \times 3 = 27$ permutations, i.e. 27 universes.
However, the sum of these three rolls can only take on the following values:

```{r}
roll_perm <- crossing(r1 = 1:3, r2 = 1:3, r3 = 1:3) %>%
  mutate(roll = r1 + r2 + r3) %>%
  count(roll)
roll_perm
```

Define a function to roll the dice for a single player, but keep track of the *states* of the game (instead of each game individually), where a state is uniquely identified by the positions and scores of players 1 and 2.

```{r}
roll_dirac <- function(players, player = 1) {
  players <- players %>% crossing(roll_perm)
  if (player == 1) {
    players <- players %>%
      mutate(pos1 = custom_mod(pos1 + roll), score1 = score1 + pos1,
             n_univ = n_univ * n)
  } else {
    players <- players %>%
      mutate(pos2 = custom_mod(pos2 + roll), score2 = score2 + pos2,
             n_univ = n_univ * n)
  }
  players %>%
      group_by(pos1, score1, pos2, score2) %>%
      summarise(n_univ = sum(n_univ), .groups = "drop")
}

# Sample input
players <- tibble(pos1 = 4, score1 = 0, pos2 = 8, score2 = 0, n_univ = 1)
# After two turns
players %>% roll_dirac(player = 1) %>% roll_dirac(player = 2)
```

After each roll, the number of universes (`n_univ`) is updated for each state.

Then a function to find the winners in each universe.
The loop works by removing winning states (`winner_universes`) from the active states (`players`) until none remain:

```{r}
find_winners <- function(players) {
  turn <- 0
  # Empty tibble to compile winners
  winner_universes <- players %>% filter(FALSE)
  
  while (nrow(players) > 0) {
    turn <- turn + 1
    
    players <- roll_dirac(players,
                          player = ifelse(turn %% 2 == 1, 1, 2))
    
    winners <- (players$score1 > 20) | (players$score2 > 20)
    if (any(winners)) {
      winner_universes <- winner_universes %>%
        bind_rows(players %>% filter(winners))
      
      players <- players %>% filter(!winners)
    }
  }
  winner_universes
}

winner_universes <- find_winners(players)

winner_universes %>%
  mutate(winner = ifelse(score1 > 20, "Player 1", "Player 2")) %>%
  group_by(winner) %>%
  summarise(n_univ = sum(n_univ), .groups = "drop") %>%
  mutate(n_univ = format(n_univ, scientific = FALSE))
```

Now apply it to my input to find the puzzle answer:

```{r}
players <- tibble(pos1 = player1, score1 = 0, pos2 = player2, score2 = 0,
                  n_univ = 1)
winner_universes <- find_winners(players)

winner_universes %>%
  mutate(winner = ifelse(score1 > 20, "Player 1", "Player 2")) %>%
  group_by(winner) %>%
  summarise(n_univ = sum(n_univ), .groups = "drop") %>%
  mutate(n_univ = format(n_univ, scientific = FALSE))
```

Python with `numpy` and `pandas`:

```{python}
from itertools import product
roll_perm = list(product([1, 2, 3], [1, 2, 3], [1, 2, 3]))
roll_perm = [sum(rolls) for rolls in roll_perm]
roll_perm = pd.DataFrame(roll_perm, columns = ['roll']) \
  .value_counts().to_frame('n').reset_index()
  
def roll_dirac(players, player = 1):
  if player == 1:
    players = players.merge(roll_perm, how = 'outer', on = 'join_key')
    players = players \
      .assign(pos1 = (players['pos1'] + players['roll'] - 1) % 10 + 1)
    players = players \
      .assign(score1 = players['score1'] + players['pos1'],
              n_univ = players['n_univ'] * players['n'])
  else:
    players = players.merge(roll_perm, how = 'outer', on = 'join_key')
    players = players \
      .assign(pos2 = (players['pos2'] + players['roll'] - 1) % 10 + 1)
    players = players \
      .assign(score2 = players['score2'] + players['pos2'],
              n_univ = players['n_univ'] * players['n'])
    
  players = players \
    .groupby(['pos1', 'score1', 'pos2', 'score2', 'join_key']) \
    .agg({'n_univ': 'sum'}).reset_index()
  return players

def find_winners(players):
  turn = 0
  winner_universes = players.drop(players.index)
  
  while len(players) > 0:
    turn += 1
    
    player = 1 if (turn % 2 == 1) else 2
    players = roll_dirac(players, player)
    
    winners = (players['score1'].values > 20) | (players['score2'].values > 20)
    if any(winners):
      winner_universes = winner_universes.append(players.loc[winners])
      players = players.loc[~winners]
  
  return winner_universes

players = pd.DataFrame({'pos1': player1, 'pos2': player2,
                        'score1': 0, 'score2': 0, 'n_univ': 1}, index = [0])
  
# I'm not aware of a pandas function similar to tidyr::crossing, so use a hacky
#  join_key column
roll_perm['join_key'] = 0
players['join_key'] = 0

winner_universes = find_winners(players)

winner_universes \
  .assign(winner = np.where(winner_universes['score1'] > 20,
                            'Player 1', 'Player 2')) \
  .groupby(['winner']) \
  .agg({'n_univ': 'sum'})
```

## Day 22: Reactor Reboot

```{r}
day22 <- read_lines(here("_posts", "2021-12-21-advent-of-code-2021-days-21-25",
                         "day22-input.txt"))
day22 %>% head()
```

### Part 1

>
Operating at these extreme ocean depths has overloaded the submarine's reactor; it needs to be rebooted.
>
The reactor core is made up of a large 3-dimensional grid made up entirely of cubes, one cube per integer 3-dimensional coordinate (`x,y,z`). Each cube can be either on or off; at the start of the reboot process, they are all off. (Could it be an old model of a reactor you've seen before?)
>
To reboot the reactor, you just need to set all of the cubes to either on or off by following a list of reboot steps (your puzzle input). Each step specifies a cuboid (the set of all cubes that have coordinates which fall within ranges for `x`, `y`, and `z`) and whether to turn all of the cubes in that cuboid on or off.
>
The initialization procedure only uses cubes that have `x`, `y`, and `z` positions of at least `-50` and at most `50`. For now, ignore cubes outside this region.
>
Execute the reboot steps. Afterward, considering only cubes in the region `x=-50..50,y=-50..50,z=-50..50`, how many cubes are on?

Parse the reboot steps:

```{r}
reboot_steps <- tibble(x = day22) %>%
  extract(
    col = x, into = c("on", "xmin", "xmax", "ymin", "ymax", "zmin", "zmax"),
    regex = "(.*) x=(.*)\\.\\.(.*),y=(.*)\\.\\.(.*),z=(.*)\\.\\.(.*)",
    convert = TRUE
  ) %>%
  # Use a logical to indicate on/off
  mutate(on = on == "on", step_num = row_number())
reboot_steps
```

For part 1, I only need the steps within -50 and +50 in each dimension:

```{r}
reboot_steps_part1 <- reboot_steps %>%
  filter(xmax >= -50, ymax >= -50, zmax >= -50,
         xmin <= 50, ymin <= 50, zmin <= 50)
```

Represent the 100x100x100 grid of cubes with an `array` and a function to update it from a single step:

```{r}
cubes <- array(FALSE, dim = c(100, 100, 100))

# For my own convenience, add 50 to each range so that I can index the array
#  with 1-100
reboot_steps_part1 <- reboot_steps_part1 %>%
  mutate(across(xmin:zmax, ~ . + 50))

switch_cubes <- function(cubes, reboot_step) {
  cubes[reboot_step$xmin:reboot_step$xmax,
        reboot_step$ymin:reboot_step$ymax,
        reboot_step$zmin:reboot_step$zmax] <- reboot_step$on
  return(cubes)
}
```

Now apply it and take the sum to get the number of `on` cubes:

```{r}
for (reboot_step in reboot_steps_part1 %>% split(.$step_num)) {
  cubes <- switch_cubes(cubes, reboot_step)
}
sum(cubes)
```

### Part 2

>
Now that the initialization procedure is complete, you can reboot the reactor.
>
Starting again with all cubes off, execute all reboot steps. Afterward, considering all cubes, how many cubes are on?

My solution to part 1 won't do here.

```{r}
reboot_steps %>%
  summarise(across(c(xmin, ymin, zmin), min),
            across(c(xmax, ymax, zmax), max))
```

Can't really work with a 20k x 20k x 20k grid in R.

Instead, for the cuboid defined in each step, I will consider every cuboid that came before it.
If I find any intersecting cuboids, I will separate them into smaller cuboids that don't intersect.
For the on/off instruction of each cuboid, I will keep the last instruction.

```{r}
get_cuboids <- function(reboot_steps) {
  cuboids <- tibble(xmin = numeric(), xmax = numeric(),
                    ymin = numeric(), ymax = numeric(),
                    zmin = numeric(), zmax = numeric())
  
  n_steps <- nrow(reboot_steps)
  for (cuboid1 in reboot_steps %>% split(.$step_num)) {
    message(paste0("Step ", cuboid1$step_num, " of ", n_steps))
    
    # After a lot of trial and error with the example input, I found out that I
    #  had an off-by-one error that was fixed by nudging the upper bounds
    cuboid1 <- cuboid1 %>%
      mutate(xmax = xmax + 1, ymax = ymax + 1, zmax = zmax + 1)
    
    # Declare an empty tibble to compile new cuboids
    new_cuboids <- cuboids %>% filter(FALSE)
    # Loop over the cuboids gathered so far
    for (i in seq_len(nrow(cuboids))) {
      cuboid2 <- cuboids %>% slice(i)
      
      # Check if the new cuboid overlaps with the old cuboid
      x_overlap <- (cuboid1$xmax > cuboid2$xmin) & (cuboid1$xmin < cuboid2$xmax)
      y_overlap <- (cuboid1$ymax > cuboid2$ymin) & (cuboid1$ymin < cuboid2$ymax)
      z_overlap <- (cuboid1$zmax > cuboid2$zmin) & (cuboid1$zmin < cuboid2$zmax)
      
      if (x_overlap & y_overlap & z_overlap) {
        # If the left edge of cuboid2 is to the left of cuboid1
        if (cuboid2$xmin < cuboid1$xmin) {
          # Slice off that portion into a new cuboid
          new_cuboids <- new_cuboids %>%
            bind_rows(cuboid2 %>% mutate(xmax = cuboid1$xmin))
          # And shrink cuboid2, as the new cuboid covers that area already
          cuboid2 <- cuboid2 %>% mutate(xmin = cuboid1$xmin)
        }
        # Do the same for the other 5 directions
        if (cuboid2$xmax > cuboid1$xmax) {
          new_cuboids <- new_cuboids %>%
            bind_rows(cuboid2 %>% mutate(xmin = cuboid1$xmax))
          cuboid2 <- cuboid2 %>% mutate(xmax = cuboid1$xmax)
        }
        if (cuboid2$ymin < cuboid1$ymin) {
          new_cuboids <- new_cuboids %>%
            bind_rows(cuboid2 %>% mutate(ymax = cuboid1$ymin))
          cuboid2 <- cuboid2 %>% mutate(ymin = cuboid1$ymin)
        }
        if (cuboid2$ymax > cuboid1$ymax) {
          new_cuboids <- new_cuboids %>%
            bind_rows(cuboid2 %>% mutate(ymin = cuboid1$ymax))
          cuboid2 <- cuboid2 %>% mutate(ymax = cuboid1$ymax)
        }
        if (cuboid2$zmin < cuboid1$zmin) {
          new_cuboids <- new_cuboids %>%
            bind_rows(cuboid2 %>% mutate(zmax = cuboid1$zmin))
          cuboid2 <- cuboid2 %>% mutate(zmin = cuboid1$zmin)
        }
        if (cuboid2$zmax > cuboid1$zmax) {
          new_cuboids <- new_cuboids %>%
            bind_rows(cuboid2 %>% mutate(zmin = cuboid1$zmax))
          cuboid2 <- cuboid2 %>% mutate(zmax = cuboid1$zmax)
        }
      }
      else {
        new_cuboids <- new_cuboids %>% bind_rows(cuboid2)
      }
    }
    new_cuboids <- new_cuboids %>% bind_rows(cuboid1)
    cuboids <- new_cuboids
  }
  return(cuboids)
}
```

As a demonstration, consider the first 3 steps (which happen to have overlapping cuboids) in just 2 dimensions:

```{r fig.height=3, fig.width=6}
reboot_steps3 <- reboot_steps %>% slice(1:3)

p <- reboot_steps3 %>%
  mutate(step_num = factor(step_num)) %>%
  ggplot(aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax)) +
  geom_rect(aes(fill = step_num),alpha = 0.5)
p
```

These are the resulting cuboids after splitting them at the intersections:

```{r fig.height=3, fig.width=6, message=FALSE, preview=TRUE}
p +
  geom_rect(
    data = get_cuboids(reboot_steps3) %>%
      # Shrink the areas slightly to visualize the borders
      mutate(across(c(xmin, ymin), ~ .x + 0.5),
             across(c(xmax, ymax), ~ .x - 0.5)),
    fill = NA, color = "black")
```

Now run it on the full input (and time it because I expect it to take a long time):

```{r part2_loop, cache=TRUE, message=FALSE}
tic()
cubes <- get_cuboids(reboot_steps)
toc()
```

~15 minute run time.

Now I have a list of cuboids which are non-overlapping.
I can filter down to just the ones that are `on` and count their volumes to get the total number of on cubes:

```{r}
cubes %>%
  filter(on) %>%
  mutate(volume = (xmax - xmin) * (ymax - ymin) * (zmax - zmin)) %>%
  summarise(n_on = sum(volume) %>% format(scientific = FALSE))
```

## Day 23: Amphipod

```{r}
day23 <- read_lines(here("_posts", "2021-12-21-advent-of-code-2021-days-21-25",
                         "day23-input.txt"))
day23 %>% str_c(collapse = "\n") %>% message()
```

### Part 1

```{python}
# Extract the letters into a list
letters = [[c for c in line if c.isalpha()] for line in r.day23[2:4]]

# Use tuples instead of lists, because they are fixed in size, just like the
#  rooms/hallway
rooms = [(letter1, letter2) for letter1, letter2 in zip(*letters)]
# The hallway is 11 empty spaces, represented by None
hallway = (None, ) * 11
# The initial state is represented with a tuple of tuples
initial_state = (hallway, *rooms)
```

Define the target state -- A, B, C and D in the rooms in order left to right:

```{python}
target_state = ((None, ) * 11, ('A', 'A'), ('B', 'B'), ('C', 'C'), ('D', 'D'))
target_rooms = {'A': 1, 'B': 2, 'C': 3, 'D': 4}
```


```{python}
# This dict maps rooms (numeric 1 = A, 2 = B, etc) to numeric locations in the
#  hallway, e.g. room B leads to hallway location 4
room_to_hall = {1: 2, 2: 4, 3: 6, 4: 8}
hall_to_room = {2: 1, 4: 2, 6: 3, 8: 4}
energy_costs = {'A': 1, 'B': 10, 'C': 100, 'D': 1000}
```


```{python}
def get_possible_moves(state):
  # For each room, consider moving the top-most amphipods
  for i in range(1, 5):
    # Look for the first non-empty space
    if state[i][0] is not None:
      # The top spot is occupied
      top_loc = 0
    elif state[i][1] is not None:
      # The bottom spot is occupied 
      top_loc = 1
    else:
      # Otherwise, nothing in this room so continue
      continue
    
    # In order to mutate the state, need to convert to list of lists
    state_list = list(map(list, state))
    letter = state_list[i][top_loc]
    
    # If this letter is in the right room, and everything below it is as well
    if target_rooms[letter] == i and \
        all(letter == letter_below for letter_below in state[i][top_loc:]):
      continue # Don't move it
          
    steps = top_loc
    # Move it
    state_list[i][top_loc] = None
    possible_locs = []
    
    # Find spaces in the hallway
    # Look to the left of the room first
    for j in range(room_to_hall[i]):
      # If not in front of the door
      if j not in [2, 4, 6, 8]:
        possible_locs.append(j)
      # If that space in the hallway is occupied, it is not possible to move
      if state_list[0][j] is not None:
        possible_locs.clear()
    for j in range(room_to_hall[i], 11):
      if state_list[0][j] is not None:
        break
      if j not in [2, 4, 6, 8]:
        possible_locs.append(j)
    
    # The new states will have unique hallways, as a letter moves from a room
    new_state = list(map(tuple, state_list))
    hallway = state[0]
    
    for loc in possible_locs:
      hallway_list = list(hallway)
      hallway_list[loc] = letter
      new_state[0] = tuple(hallway_list)
      # Count the number of steps to get to this space, and multiply by energy
      energy = (steps + 1 + abs(loc - room_to_hall[i])) * energy_costs[letter]
      yield tuple(new_state), energy
      
  # For each amphipod in the hallway, consider moving into rooms
  for i,letter in enumerate(state[0]):
    if letter is None: continue
    
    # Find the target room for this letter
    target_room = target_rooms[letter]
    # And its current occupants
    room_letters = set(state[target_room]).discard(None)
    # And the hallway location right outside
    target_hallway = room_to_hall[target_room]
    # If the room has other letters in it, don't both moving into it
    if room_letters and {letter} != room_letters:
      continue
    
    # If to the left of the target location
    if i < target_hallway:
      # Consider all locations to the left
      hall_locs = slice(i + 1, target_hallway + 1)
    else:
      # Otherwise, all locations to the right
      hall_locs = slice(target_hallway, i)
    
    # If there is an amphipod in the way, break
    for loc in state[0][hall_locs]:
      if loc is not None:
        break
    else:
      steps = abs(i - target_hallway)
      state_list = list(map(list, state))
      # Remove it from the hall
      state_list[0][i] = None
      # Get the list of current room occupants
      room_list = state_list[target_room]
      
      # Consider all locations in the room
      for room_loc, other_letter in reversed(list(enumerate(room_list))):
        if other_letter is None: break
      
      # If the top location is empty (as expected) move the amphipod there
      assert room_list[room_loc] is None
      room_list[room_loc] = letter
      steps += room_loc + 1
      
      energy = steps * energy_costs[letter]
      yield tuple(map(tuple, state_list)), steps * energy
```


```{python}
from functools import cache

@cache
def steps_to_target(state):
  if state == target_state: return 0
  
  possible_costs = []
  
  for new_state, energy in get_possible_moves(state):
    possible_costs.append(energy + steps_to_target(new_state))
    
  return min(possible_costs)
```

```{python, eval=FALSE}
import sys
print(sys.getrecursionlimit())
sys.setrecursionlimit(30000)

steps_to_target(initial_state)
```

## Day 24: Arithmetic Logic Unit

```{r}
day24 <- read_lines(here("_posts", "2021-12-21-advent-of-code-2021-days-21-25",
                         "day24-input.txt"))
head(day24)
```

### Part 1

These are some very confusing instructions.
My TLDR is that the puzzle input is the code, through which I run many different 14 digit model numbers, and find the largest valid number (that contains no `0` digits).
Parse the MONAD instruction list:

```{r}
monad <- tibble(x = day24) %>%
  mutate(step_num = row_number()) %>%
  separate(x, into = c("operation", "var1", "var2"), sep = " ", fill = "right")
monad
```

`r nrow(monad)` steps in the program.
How many input operations are there?

```{r}
monad %>% count(operation)
```

14 inputs (`inp`) for the 14 digit model number.
So I need make a function which takes any 14 digit model number (that doesn't contain 0), and will be considered valid if the `z` variable is non-zero.

```{r}
check_model_number <- function(model_number) {
  model_number <- strsplit(model_number, "")[[1]]
  
  # Place the model number into the input instructions
  monad$var2[is.na(monad$var2)] <- model_number
  
  reduce(monad %>% split(.$step_num), run_monad_instruction,
         .init = list(w = 0, x = 0, y = 0, z = 0))
}

run_monad_instruction <- function(vars, instr) {
  # Variable 2 is either a number
  if (!is.na(as.numeric(instr$var2))) {
    var2 <- as.numeric(instr$var2)
  # Or variable which has a number assigned
  } else {
    var2 <- as.numeric(vars[[instr$var2]])
  }
  
  switch(instr$operation,
    "inp" = {
      vars[[instr$var1]] <- var2
    },
    "add" = {
      vars[[instr$var1]] <- vars[[instr$var1]] + var2
    },
    "div" = {
      stopifnot(var2 != 0)
      vars[[instr$var1]] <- trunc(vars[[instr$var1]] / var2)
    },
    "mod" = {
      stopifnot(vars[[instr$var1]] >= 0)
      stopifnot(var2 > 0)
      vars[[instr$var1]] <- vars[[instr$var1]] %% var2
    },
    "eql" = {
      vars[[instr$var1]] <- ifelse(vars[[instr$var1]] == var2, 1, 0)
    }
  )
  return(vars)
}
```

Now I can check any 14 digit number, like the example input `13579246899999`:

```{r warning=FALSE}
test_model_number <- "13579246899999"
check_model_number(test_model_number)
```

This number returns a non-zero `z`, and so is invalid.

The problem now is: how to check so many model numbers?
I could start from `99999999999999` and decrease by 1 until I find a valid number.

```{r warning=FALSE}
check_model_number("99999999999999")
```

This is not a valid number.

But with 9^14 = `r scales::comma(9^14)` possible numbers to check, the brute force approach would not finish in any reasonable time frame.
There has to be a simpler way to approach the problem.
Looking at the raw input, there is definitely a pattern to the instructions.
The input instructions come at regular intervals (1st, 19th, 37th, 55th, ...).
Split the `monad` by the input instructions, and compare instructions side-by-side:

```{r message=FALSE}
day24 %>%
  split(cumsum(str_detect(., "inp"))) %>%
  map_dfc(as_tibble) %>%
  rename_with(~str_replace(., "value...", "input ")) %>%
  mutate(step_num = row_number()) %>%
  gt(rowname_col = "step_num")
```

The only steps which differ from input to input to:

* Step 1: `inp w` which will take a different input every time
* Step 5: `div z 1` and `div z 26`
  * Because the `div` operation rounds down the result, this 
* Step 6: `add x 10`, `13`, `15`, `-12`, `14`, `-2`, `11`, `-3`, `-13`
* Step 16: `add y 10`, `5`, `12`, `6`, `4`, `15`, `3`, `7`, `11`, `2`

So I can write a simple function which takes a few variables and runs through all the steps:

```{r}
monad_simple_step <- function(z = 0, w = 1, step5 = 1, step6 = 10, step16 = 3) {
  # Step 2
  x <- 0
  # Step 3
  x <- z
  # Step 4
  x <- x %% 26
  # Step 5
  z <- trunc(z / step5)
  # Step 6
  x <- x + step6
  # Step 7
  x <- as.numeric(x == w)
  # Step 8
  x <- as.numeric(x == 0)
  # Step 9
  y <- 0
  # Step 10
  y <- y + 25
  # Step 11
  y <- y * x
  # Step 12
  y <- y + 1
  # Step 13
  z <- z * y
  # Step 14
  y <- 0
  # Step 15
  y <- y + w
  # Step 16
  y <- y + step16
  # Step 17
  y <- y * x
  # Step 18
  z <- z + y
  # Output
  z
}
monad_simple_step(w = 5)
monad_simple_step(z = 8, w = 3, step5 = 26, step6 = -12, step16 = 4)
```

Obviously a lot of these steps can be simplified further.
A simpler function could have two lines like this:

```{r}
monad_simple_step <- function(z = 0, w = 1, step5 = 1, step6 = 10, step16 = 3) {
  x <- as.numeric(((z %% 26) + step6) != w)
  trunc(z / step5) * ((25 * x) + 1) + (w + step16) * x
}
monad_simple_step(w = 5)
monad_simple_step(z = 8, w = 3, step5 = 26, step6 = -12, step16 = 4)
```

```{r}
monad_simple <- monad %>%
  mutate(input_step = cumsum(operation == "inp")) %>%
  group_by(input_step) %>%
  mutate(sub_step = row_number()) %>%
  ungroup() %>%
  filter(sub_step %in% c(5, 6, 16)) %>%
  select(input_step, sub_step, var2) %>%
  pivot_wider(names_from = sub_step, values_from = var2) %>%
  rename_with(~paste0("step", .), .cols = c(`5`, `6`, `16`)) %>%
  mutate(across(everything(), as.integer))
monad_simple
```


```{r}
check_model_number_simple <- function(model_number) {
  m <- monad_simple %>%
    mutate(w = as.integer(strsplit(model_number, "")[[1]]))
  
  reduce(
    transpose(m),
    function(z, args) {
      monad_simple_step(z, args$w, args$step5, args$step6, args$step16)
    },
    .init = 0
  )
}
check_model_number_simple("99999999999999")
```

But this still requires checking too many numbers, aid needs to be broken down even more.

Consider the line:

```{r eval=FALSE}
x <- as.numeric(((z %% 26) + step6) != w)
```

The will only ever be `0` or `1`, depending on equality with the input value `w` (which ranges `1` to `9`).
Also notice that `step6` and the sign of `step5` are related:

```{r}
monad_simple %>% count(step5, step6)
```

Since `w` can only take values `1` to `9`, any values of `step6 > 9` will also lead to inequality with `w` and therefore `x = 1`.
The values of `step6 > 9` correspond to `step5 = 1`, and so `x` is always `1`.

So the `x` value works sort of as an on/off switch that feeds into the next line:

```{r eval=FALSE}
term1 <- trunc(z / step5)
term2 <- (25 * x) + 1
term3 <- (w + step16) * x
z <- term1 * term2 + term3
```

* If `x = 0`, then `term2 = 1`, and this term does nothing to `z`
* If `x = 0`, then `term3 = 0`, and this term does nothing to `z`
* If `x = 1`, then `term2 = 26`
* If `x = 1`, then `term3 = w + step16`

The number 26 occurring so frequently means we should be thinking in base 26 numbers.
Here is what happens to `z` if `x = 1, and how we can think of `z` in base 26:

* `term1`
    * `step5 = 1`
        * `term1 = z` (no change)
    * `step5 = 26`
        * `term1 = z / 26` (remove an order)
* `term2`
    * `= 1` (no change)
    * `= 26` (add an order)
* `term3`
    * `w + step16` (add to the number)
        
I'm not very familiar with these terms as a non-CS grad, but apparently this mimics a [stack data structure](https://en.wikipedia.org/wiki/Stack_(abstract_data_type) which can *push* a value `w` (adds it to the stack) or *pop* the most recent (remove from the stack).
`term3` is *pushing* the value of `w + step16` onto the stack (in base 26), if `step5 = 1`, otherwise `step5 = 26` pops the last value.
To get a valid model number, we need `z = 0`, so these digits need to be *popped* off the stack.
There are 7 each of `step5 = 1` and `step5 = 26` so we can equally add and remove the digits until the stack is empty.

This means that the lines with `step5 = 26`, `x = as.numeric(((z %% 26) + step6) != w)` must be 0, which requires that the pushed digit `w + step16` from the previous step be equal to the next step's `w - step6`.

My input is as follows:

```{r}
monad_simple %>%
  transmute(
    input_step,
    push_pop = ifelse(step5 == 1, "push", "pop"),
    step6, step16,
    operation = ifelse(
      push_pop == "push",
      glue::glue("push model_num[{input_step}] + {step16}"),
      glue::glue("pop requires model_num[{input_step}] = popped_val {step6}")
    )
  ) %>%
  gt()
```


So the model number requirements unique to my MONAD input are:

* `model_num[4] = model_num[3] - 12 + 12`
* `model_num[6] = model_num[5] - 2 + 6`
* `model_num[8] = model_num[7] - 12 + 15`
* `model_num[11] = model_num[10] - 3 + 11`
* `model_num[12] = model_num[9] - 13 + 7`
* `model_num[13] = model_num[2] - 12 + 5`
* `model_num[14] = model_num[1] - 13 + 10`

* `model_num[1] = 9`
    * `model_num[14] = 9 - 3 = 6`
* `model_num[2] = 9`
    * `model_num[13] = 9 - 7 = 2`
* `model_num[3] = 9`
    * `model_num[4] = 9`
* `model_num[5] = 5`
    * `model_num[6] = 5 + 4 = 9`
* `model_num[7] = 6`
    * `model_num[8] = 6 + 3 = 9`
* `model_num[10] = 1`
    * `model_num[11] = 1 + 8 = 9`
* `model_num[9] = 9`
    * `model_num[12] = 9 - 6 = 3`
    
`99995969919326`

```{r}
check_model_number_simple("99995969919326")
```

### Part 2

* `model_num[1] = 4`
    * `model_num[14] = 4 - 3 = 1`
* `model_num[2] = 8`
    * `model_num[13] = 8 - 7 = 1`
* `model_num[3] = 1`
    * `model_num[4] = 1`
* `model_num[5] = 1`
    * `model_num[6] = 1 + 4 = 5`
* `model_num[7] = 1`
    * `model_num[8] = 1 + 3 = 4`
* `model_num[10] = 1`
    * `model_num[11] = 1 + 8 = 9`
* `model_num[9] = 7`
    * `model_num[12] = 7 - 6 = 1`
    
`48111514719111`

```{r}
check_model_number_simple("48111514719111")
```


## Reproducibility {.appendix}

<details><summary>Session info</summary>

```{r echo=FALSE}
devtools::session_info()$platform
devtools::session_info()$packages %>%
  rmarkdown::paged_table()
```

</details>

<details><summary>Git repository</summary>

```{r echo=FALSE}
git2r::repository()
```

</details>

```{r echo=FALSE}
dunnr::get_distill_source(date = params$date, slug = params$slug)
```

